Definition of a Counter, Types of Counters

A counter is a digital circuit that counts pulses arriving at its input. The counter has a pre-divider with a value P. After each counted pulse, the counter skips the next P pulses. The counter triggers events upon reaching specified values. Both the counter’s value and the parameter P are integers in the range from 0 to UINT64_MAX.

There are several types of counters:

    Modulo Counter
    The modulo counter counts from zero up to the maximum value M, and then starts over from zero. This counter reports an overflow event when its value changes from M to zero. If the maximum value is zero, then the counter always remains at zero and reports an overflow on every counted pulse.

    Fibonacci Counter
    The Fibonacci counter counts from zero up to UINT64_MAX, after which it stops. This counter reports an event when its value reaches a Fibonacci number, that is 1, 2, 3, 5, 8, etc.

    Geometric-Decimal Counter
    The geometric-decimal counter counts in successive cycles from 0 to 9, then from 0 to 99, then from 0 to 999, …, from 0 to 999999999999, and then again from 0 to 9, etc. This counter reports an overflow event when its value changes from the maximum value to zero.

Task

Write a program that manages a collection of counters. The program reads data from standard input.

A correct input line must be in one of the following formats:

• M (C) (P) (M)
  Creates a new modulo counter with number <C> with parameters <P> and <M>.
  
• F (C) (P)
  Creates a new Fibonacci counter with number <C> with parameter <P>.
  
• G (C) (P)
  Creates a new geometric-decimal counter with number <C> with parameter <P>.
  
• D (C)
  Deletes the counter with number <C>.
  
• P (C)
  Prints the letter C, followed by a space, the counter number, a space, the counter’s value, and a newline.
  
• A (T)
  Sends T pulses to all counters. This causes the program to print to standard output the events generated by all counters since the previous execution of this command or since the start of the program, if this command is executed for the first time. Each event is printed on a separate line ending with a newline character and consists of the letter E, a space, the number C of the counter that generated the event, a space, and the number of pulses since the previous execution of this command or since the start of the program (if this is the first execution). The events are printed in chronological order according to their report time. Events occurring at the same time are sorted in ascending order by the counter numbers reporting them. If there are no events, nothing is printed.

The initial value of any new counter is zero. The parameters C, P, M, T are integers in the range from 0 to UINT64_MAX.

Command names and their parameters are separated by a single space. Input lines are separated by newlines. A newline after the last line is optional. Valid input does not contain any whitespace characters other than those specified above.

Error Handling

The program continuously checks whether the input data contain errors. For each erroneous line, the program prints a diagnostic message to standard output in the following format:

  ERROR L

where L denotes the line number (lines are numbered starting from 1). The error message ends with a newline. The program ignores the content of erroneous lines.

An input line should be treated as erroneous if it attempts to create a new counter when a counter with the given number already exists, or if it attempts to delete a non-existent counter.

Formal Requirements

• The program should exit with return code 0. 
• The implementation should use the object-oriented programming paradigm. 
• The implementation should be divided into several modules. Each module should be in a separate file with the .cppm extension. 
• It is forbidden to use preprocessor commands starting with the character #. 
• A makefile (or Makefile) must be provided to compile the program using the make command. Invoking make without parameters should produce an executable called counters. The script should include .PHONY and clean targets (and may include additional targets such as test). The makefile should include incremental compilation rules and describe the dependencies between files.
